name: ä¼šè­°è­°äº‹éŒ²
on:
  repository_dispatch:
    types: [meeting-completed]
  workflow_dispatch:
    inputs:
      meeting_url:
        description: 'tl;dv meeting URL'
        required: true
        type: string
      meeting_title:
        description: 'Meeting Title'
        required: true
        type: string

permissions:
  issues: write
  pull-requests: write
  contents: write
  discussions: write

jobs:
  process-meeting:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          
      - name: Install dependencies
        run: |
          npm install @octokit/rest openai moment
          
      - name: Process Meeting Data
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          TLDV_API_KEY: ${{ secrets.TLDV_API_KEY }}
          MEETING_URL: ${{ github.event.inputs.meeting_url || github.event.client_payload.meeting_url }}
          MEETING_TITLE: ${{ github.event.inputs.meeting_title || github.event.client_payload.meeting_title }}
        run: |
          node << 'EOF'
          const { Octokit } = require("@octokit/rest");
          const OpenAI = require('openai');
          const moment = require('moment');
          
          const octokit = new Octokit({
            auth: process.env.GITHUB_TOKEN,
          });
          
          const openai = new OpenAI({
            apiKey: process.env.OPENAI_API_KEY,
          });
          
          async function processMeeting() {
            console.log('ğŸ¤ ä¼šè­°è­°äº‹éŒ²å‡¦ç†é–‹å§‹');
            
            const meetingUrl = process.env.MEETING_URL;
            const meetingTitle = process.env.MEETING_TITLE || 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä¼šè­°';
            const meetingDate = moment().format('YYYY-MM-DD');
            
            // tl;dv APIã‹ã‚‰éŸ³å£°è­°äº‹éŒ²å–å¾—ï¼ˆä»®å®Ÿè£…ï¼‰
            let transcriptText = '';
            if (process.env.TLDV_API_KEY) {
              try {
                // å®Ÿéš›ã®tl;dv APIå®Ÿè£…ã¯ã“ã“ã«
                console.log('ğŸ“ tl;dv APIã‹ã‚‰è­°äº‹éŒ²å–å¾—ä¸­...');
                transcriptText = await fetchTldvTranscript(meetingUrl);
              } catch (error) {
                console.error('âŒ tl;dv APIå–å¾—ã‚¨ãƒ©ãƒ¼:', error);
                transcriptText = `è­°äº‹éŒ²ã®è‡ªå‹•å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚
æ‰‹å‹•ã§è­°äº‹éŒ²ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚

ä¼šè­°URL: ${meetingUrl}
ä¼šè­°æ—¥æ™‚: ${meetingDate}
ä¼šè­°ã‚¿ã‚¤ãƒˆãƒ«: ${meetingTitle}`;
              }
            } else {
              console.log('âš ï¸ tl;dv APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
              transcriptText = 'tl;dv APIã‚­ãƒ¼ãŒæœªè¨­å®šã®ãŸã‚ã€è­°äº‹éŒ²ã®è‡ªå‹•å–å¾—ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸã€‚';
            }
            
            // OpenAI ã«ã‚ˆã‚‹è­°äº‹éŒ²åˆ†æãƒ»è¦ç´„
            let analysis = null;
            if (process.env.OPENAI_API_KEY && transcriptText) {
              try {
                console.log('ğŸ¤– AIè­°äº‹éŒ²åˆ†æä¸­...');
                analysis = await analyzeTranscript(transcriptText, meetingTitle);
              } catch (error) {
                console.error('âŒ AIåˆ†æã‚¨ãƒ©ãƒ¼:', error);
              }
            }
            
            // GitHub Discussions ã«è­°äº‹éŒ²æŠ•ç¨¿
            await createMeetingDiscussion(meetingTitle, meetingDate, transcriptText, analysis, meetingUrl);
            
            // æ±ºå®šäº‹é …ã‹ã‚‰GitHub Issueä½œæˆ
            if (analysis && analysis.actionItems && analysis.actionItems.length > 0) {
              await createActionItemIssues(analysis.actionItems, meetingDate);
            }
            
            // Figmaæ›´æ–°æŒ‡ç¤ºã®å‡¦ç†
            if (analysis && analysis.figmaUpdates && analysis.figmaUpdates.length > 0) {
              await createFigmaUpdateIssues(analysis.figmaUpdates, meetingDate);
            }
            
            console.log('âœ… ä¼šè­°è­°äº‹éŒ²çµ±åˆå‡¦ç†å®Œäº†');
          }
          
          async function fetchTldvTranscript(meetingUrl) {
            // tl;dv APIå®Ÿè£…ï¼ˆå®Ÿéš›ã®APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã«åˆã‚ã›ã¦èª¿æ•´ï¼‰
            // ã“ã‚Œã¯ä»®å®Ÿè£…ã§ã™
            return `ä¼šè­°ã®éŸ³å£°è­°äº‹éŒ²ãŒã“ã“ã«å…¥ã‚Šã¾ã™ã€‚
            
å®Ÿéš›ã®ä¼šè­°å†…å®¹:
- ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆé€²æ—ã®ç¢ºèª
- æ–°æ©Ÿèƒ½ã®è¦ä»¶ã«ã¤ã„ã¦è¨è­°
- æ¬¡é€±ã®ã‚¿ã‚¹ã‚¯å‰²ã‚Šå½“ã¦ç¢ºèª
- ãƒªã‚¹ã‚¯äº‹é …ã®å¯¾å¿œç­–æ¤œè¨`;
          }
          
          async function analyzeTranscript(transcript, meetingTitle) {
            const completion = await openai.chat.completions.create({
              model: "gpt-4",
              messages: [
                {
                  role: "system",
                  content: `ã‚ãªãŸã¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç®¡ç†ã®å°‚é–€å®¶ã§ã™ã€‚ä¼šè­°ã®è­°äº‹éŒ²ã‚’åˆ†æã—ã€ä»¥ä¸‹ã®é …ç›®ã‚’æŠ½å‡ºã—ã¦ãã ã•ã„ï¼š

1. æ±ºå®šäº‹é …ï¼ˆå…·ä½“çš„ãªæ±ºå®šå†…å®¹ï¼‰
2. ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¢ã‚¤ãƒ†ãƒ ï¼ˆæ‹…å½“è€…ã€æœŸé™ã€å…·ä½“çš„ãªã‚¿ã‚¹ã‚¯ï¼‰
3. ãƒªã‚¹ã‚¯ãƒ»èª²é¡Œï¼ˆç™ºç”Ÿã—ã¦ã„ã‚‹å•é¡Œã‚„æ‡¸å¿µäº‹é …ï¼‰
4. Figmaæ›´æ–°æŒ‡ç¤ºï¼ˆUI/UXãƒ‡ã‚¶ã‚¤ãƒ³ã«é–¢ã™ã‚‹å¤‰æ›´è¦æ±‚ï¼‰
5. æ¬¡å›ä¼šè­°ã¾ã§ã®å®¿é¡Œ

JSONå½¢å¼ã§å›ç­”ã—ã¦ãã ã•ã„ã€‚`
                },
                {
                  role: "user",
                  content: `ä¼šè­°ã‚¿ã‚¤ãƒˆãƒ«: ${meetingTitle}
è­°äº‹éŒ²å†…å®¹:
${transcript}`
                }
              ],
              temperature: 0.3,
            });
            
            try {
              return JSON.parse(completion.choices[0].message.content);
            } catch (error) {
              console.error('AIåˆ†æçµæœã®JSONè§£æã‚¨ãƒ©ãƒ¼:', error);
              return {
                decisions: [],
                actionItems: [],
                risks: [],
                figmaUpdates: [],
                homework: []
              };
            }
          }
          
          async function createMeetingDiscussion(title, date, transcript, analysis, meetingUrl) {
            const owner = process.env.GITHUB_REPOSITORY.split('/')[0];
            const repo = process.env.GITHUB_REPOSITORY.split('/')[1];
            
            let body = `# ğŸ“… ${title} - ${date}

## ğŸ”— ä¼šè­°æƒ…å ±
- **æ—¥æ™‚**: ${date}
- **ä¼šè­°URL**: ${meetingUrl || 'N/A'}

## ğŸ“ è­°äº‹éŒ²
${transcript}
`;
            
            if (analysis) {
              body += `
## ğŸ¯ æ±ºå®šäº‹é …
${analysis.decisions ? analysis.decisions.map(d => `- ${d}`).join('\n') : 'æ±ºå®šäº‹é …ãªã—'}

## âš¡ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¢ã‚¤ãƒ†ãƒ   
${analysis.actionItems ? analysis.actionItems.map(a => `- **${a.assignee || 'æœªæŒ‡å®š'}**: ${a.task} (æœŸé™: ${a.deadline || 'æœªè¨­å®š'})`).join('\n') : 'ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¢ã‚¤ãƒ†ãƒ ãªã—'}

## âš ï¸ ãƒªã‚¹ã‚¯ãƒ»èª²é¡Œ
${analysis.risks ? analysis.risks.map(r => `- ${r}`).join('\n') : 'ãƒªã‚¹ã‚¯ãƒ»èª²é¡Œãªã—'}

## ğŸ¨ Figmaæ›´æ–°æŒ‡ç¤º
${analysis.figmaUpdates ? analysis.figmaUpdates.map(f => `- ${f}`).join('\n') : 'Figmaæ›´æ–°æŒ‡ç¤ºãªã—'}

## ğŸ“‹ æ¬¡å›ã¾ã§ã®å®¿é¡Œ
${analysis.homework ? analysis.homework.map(h => `- ${h}`).join('\n') : 'å®¿é¡Œãªã—'}
`;
            }
            
            body += `
---
*è‡ªå‹•ç”Ÿæˆæ—¥æ™‚: ${moment().format('YYYY-MM-DD HH:mm:ss')}*
`;
            
            try {
              const { data: discussion } = await octokit.rest.teams.createDiscussionInOrg({
                org: owner,
                team_slug: 'project-team',
                title: `ğŸ“… ${title} - ${date}`,
                body: body
              });
              
              console.log(`ğŸ“ è­°äº‹éŒ²Discussionä½œæˆå®Œäº†: ${discussion.html_url}`);
            } catch (error) {
              console.error('âŒ Discussionä½œæˆã‚¨ãƒ©ãƒ¼:', error);
              
              // Fallback: Issue ã¨ã—ã¦ä½œæˆ
              await octokit.rest.issues.create({
                owner,
                repo,
                title: `ğŸ“… ä¼šè­°è­°äº‹éŒ²: ${title} - ${date}`,
                body: body,
                labels: ['meeting-minutes', 'documentation']
              });
            }
          }
          
          async function createActionItemIssues(actionItems, meetingDate) {
            const owner = process.env.GITHUB_REPOSITORY.split('/')[0];
            const repo = process.env.GITHUB_REPOSITORY.split('/')[1];
            
            for (const item of actionItems) {
              try {
                const { data: issue } = await octokit.rest.issues.create({
                  owner,
                  repo,
                  title: `[ã‚¢ã‚¯ã‚·ãƒ§ãƒ³] ${item.task}`,
                  body: `## ğŸ“‹ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¢ã‚¤ãƒ†ãƒ è©³ç´°

**ã‚¿ã‚¹ã‚¯**: ${item.task}
**æ‹…å½“è€…**: ${item.assignee || 'æœªæŒ‡å®š'}
**æœŸé™**: ${item.deadline || 'æœªè¨­å®š'}
**ä¼šè­°æ—¥**: ${meetingDate}

## ğŸ“ èƒŒæ™¯ãƒ»è©³ç´°
${item.description || 'N/A'}

---
*${meetingDate}ã®ä¼šè­°ã§æ±ºå®šã•ã‚ŒãŸã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¢ã‚¤ãƒ†ãƒ ã§ã™*`,
                  labels: ['action-item', 'from-meeting'],
                  assignees: item.assignee ? [item.assignee] : []
                });
                
                console.log(`âš¡ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¢ã‚¤ãƒ†ãƒ Issueä½œæˆ: ${issue.html_url}`);
              } catch (error) {
                console.error('âŒ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¢ã‚¤ãƒ†ãƒ Issueä½œæˆã‚¨ãƒ©ãƒ¼:', error);
              }
            }
          }
          
          async function createFigmaUpdateIssues(figmaUpdates, meetingDate) {
            const owner = process.env.GITHUB_REPOSITORY.split('/')[0];
            const repo = process.env.GITHUB_REPOSITORY.split('/')[1];
            
            for (const update of figmaUpdates) {
              try {
                const { data: issue } = await octokit.rest.issues.create({
                  owner,
                  repo,
                  title: `[Figma] ${update.title || 'ãƒ‡ã‚¶ã‚¤ãƒ³æ›´æ–°è¦æ±‚'}`,
                  body: `## ğŸ¨ Figmaãƒ‡ã‚¶ã‚¤ãƒ³æ›´æ–°è¦æ±‚

**æ›´æ–°å†…å®¹**: ${update.description || update}
**ä¼šè­°æ—¥**: ${meetingDate}

## ğŸ“‹ ã‚¿ã‚¹ã‚¯è©³ç´°
- [ ] Figmaãƒ‡ã‚¶ã‚¤ãƒ³ã®æ›´æ–°å®Ÿæ–½
- [ ] ãƒ‡ã‚¶ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ ã®èª¿æ•´
- [ ] é–¢é€£ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ç¢ºèª
- [ ] é–‹ç™ºãƒãƒ¼ãƒ ã¸ã®å…±æœ‰

## ğŸ”— é–¢é€£ãƒªãƒ³ã‚¯
- Figma URL: [æ›´æ–°å¾Œã«è¿½è¨˜]

---
*${meetingDate}ã®ä¼šè­°ã§æ±ºå®šã•ã‚ŒãŸãƒ‡ã‚¶ã‚¤ãƒ³æ›´æ–°è¦æ±‚ã§ã™*`,
                  labels: ['figma', 'design', 'from-meeting', 'ui-ux']
                });
                
                console.log(`ğŸ¨ FigmaUpdateIssueä½œæˆ: ${issue.html_url}`);
              } catch (error) {
                console.error('âŒ FigmaUpdateIssueä½œæˆã‚¨ãƒ©ãƒ¼:', error);
              }
            }
          }
          
          processMeeting().catch(console.error);
          EOF
          
      - name: Notify Team
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          MEETING_TITLE: ${{ github.event.inputs.meeting_title || github.event.client_payload.meeting_title }}
        run: |
          if [ -n "$SLACK_WEBHOOK_URL" ]; then
            curl -X POST -H 'Content-type: application/json' \
              --data "{\"text\":\"ğŸ“… ä¼šè­°è­°äº‹éŒ²ãŒå‡¦ç†ã•ã‚Œã¾ã—ãŸ: **${MEETING_TITLE}**\nğŸ”— <${{ github.server_url }}/${{ github.repository }}/discussions|Discussionsã§AIã‚µãƒãƒªãƒ¼ã‚’ç¢ºèª> \nâš¡ æ–°ã—ã„ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¢ã‚¤ãƒ†ãƒ ãŒIssueã¨ã—ã¦ä½œæˆã•ã‚Œã¾ã—ãŸ\"}" \
              $SLACK_WEBHOOK_URL
          fi
          
      - name: Update Meeting Tracker
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # ä¼šè­°ãƒˆãƒ©ãƒƒã‚«ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ã®æ›´æ–°
          echo "$(date '+%Y-%m-%d'): ${{ github.event.inputs.meeting_title || github.event.client_payload.meeting_title }}" >> meetings.log
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add meetings.log
          git commit -m "ğŸ“… ä¼šè­°è¨˜éŒ²æ›´æ–°: ${{ github.event.inputs.meeting_title || github.event.client_payload.meeting_title }}" || exit 0
          git push
